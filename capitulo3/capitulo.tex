\chapter{Estudio de Reuseport}

Como ya se estudió, los problemas del escenario multithreading reconocidos en el capítulo anterior impactan principalmente en los tiempos de operaciones de tareas en que el tráfico y, por ende, el tiempo de respuesta, es un elemento prioritario a garantizar. Entendiendo éste problema es que varios gigantes de la industria han planteado mecanismos alternativos que permitan aprovechar mejor los recursos de los computadores de arquitecturas modernas al emplear programación paralela ???????????. En ésta linea, la propuesta más prometedora hasta la fecha es la brindada por Google, denominada \emph{Reuseport}.

\emph{Reuseport} \cite{slides:googleReuseport} es una de las soluciones más usadas para el problema descrito por su gran efectividad en la practica. Corresponde a un desarrollo de Tom Herbert --Ingeniero de Google-- desarrollado precisamente para atender los bajos desempeños generados a emplear un esquema de consumo de sockets como el planteado hasta el momento. El trabajo de Herbert plantea que las distintas estratégias que se puedan adoptar sobre un único socket para mejorar la performance en su acceso concurrente terminan no resultando efectivas por mantener el punto de contención al compartir la misma estructura.

\begin{figure}[h!]
	\centering
	\hspace*{\fill}
	\subfigure[Socket Tradicional]{
		\includegraphics[width=.45\textwidth]{imagenes/socketNormal.png}
	}\hfill
	\subfigure[Socket con opción Reuseport activada]{
		\includegraphics[width=.45\textwidth]{imagenes/socketReuseport.png}
		\label{fig:soReuseport}
	}
	\caption{Comparativo del funcionamiento de sockets tradicionales con respecto a Reuseport. En éste último, basta con que el primer socket que enlace al puerto en cuestión tenga la opción habilitada para que cualquier socket posterior se pueda sobre acomplar sobre el mismo puerto, compartiendo así el consumo de datos del mismo.}
	\label{fig:socketHandshake}
	\hspace*{\fill}
\end{figure}

Reuseport se plantea como una opción para los sockets estándar de Linux que promete una mejora en los tiempos de consumo en la atención a un determinado puerto. Dicha opción permite compartir un mismo puerto local del sistema entre múltiples sockets distintos. De ésta manera, conservando el esquema multithread, cada thread puede tener exclusividad en el consumo de un socket, eliminando el punto de contención único que se ocaciona al compartir un sólo socket. Al usar la opción \emph{Reuseport}, la tarea de distribución de paquetes entre los distintos sockets que compartan un puerto local es delegada directamente al kernel, el cual asigna aleatoreamente los paquetes recibidos entre los sockets que escuchan el mismo puerto.

\section{Implementación}
La opción está implementada íntegramente en el código fuente del kernel, distribuida entre distintos archivos que hacen uso de la misma. Por sólo mencionar algunos, los archivos 


\section{Uso en la práctica}
La adopción de ésta funcionalidad ha sido incorporada a software con requerimientos de alta disponibilidad de atención de consultas con buenos resultados \cite{paper:apache}. En la práctica, para usar ésta opción se debe modificar la estructura socket que primero tome control del puerto local para escucharlo por medio de la llamada \verb=bind()=. Ello se puede hacer por medio de la llamada de sistema \verb=setsockopt()= con la cual se puede modificar el descriptor de una estrutura socket. En éste punto es necesario entregar la constante \verb=SO_REUSEPORT= como una opción para activar en la estructura socket. Con ello, el puerto puede ser posteriormente re-acoplado por otros sockets sin la necesidad de que éstos últimos tengan la característica activada (Ver imagen \ref{fig:soReuseport}).

\section{Rendimiento}

\subsection{Diferencias entre arquitecturas}


\section{Optimizaciones Adicionales}
Los resultados anteriores evidencian un claro incremento en el rendimiento alcanzable por la prueba ya conocida aprovechando múltiples hilos de ejecución. Sin embargo cabe preguntarse si será posible mejorar aún más esos resultados combinando la opción de \emph{Reuseport} con técnicas de consumo concurrente sobre los sockets. Una hipótesis que apoya ésta idea se basa en que, al emplear la opción \emph{Reuseport} los sockets tienen una menor cuota de consumo cada uno, por lo tanto, un acceso concurrente en ese escenario de bajo consumo podría impactar en una reducción de tiempos finales.

En la presente sección se validará el rendimiento alcanzable por la opción \emph{Reuseport} usándola en combinación con diferentes estratégias de multithreading como las vistas en el capítulo anterior.

\subsection{Incorporación de Multithreading}

\subsection{Incorporación de Multithreading con Processor Affinity}

\subsubsection{All0}
\subsubsection{Equitative}
\subsubsection{Comparación de esquemas}


\section{Aspectos Negativos}

El esquema que propone Reuseport re-plantea uno de los principios fundamentales que postula el modelo OSI, que es la relación uno a uno entre estructuras sockets y direcciones de puertos locales. Como \emph{Reuseport} plantea la copartición de puertos locales, se pierde la exclusividad de los mismos para cada socket. Otra caracteristica que trastoca ésta alternativa es la modificación en la manera de programación de aplicaciones. Como se mencionó, el uso de \emph{Reuseport} está condicionado a la habilitación de dicha opción a los sockets previo al momento de su acoplamiento con el puerto local a escuchar. Ésta situación significa en la práctica estar concientes de que toda aplicación que desee hacer uso de ésta característica debe modificar secciones profundas de su impleentación en el código fuente para habilitarla.

Por otro lado, dado su funcionamiento la opción de \emph{Reuseport} está incorporada como código fuente del kernel de Linux, estando disponible según sus creadores en los kernels con versiones posteriores a la 3.9 (Finales del año 2013), ello no es del todo correcto. Conocido es el caso de las distribuciones de Linux basadas en Debian --incluido el popular Ubuntu-- donde se han presentado varios problemas en versiones recientes las cuales, a pesar de contar con la implementación fuente de \emph{Reuseport}, poseen la constante de activación de la característica como código comentado [AKA UNA REF. A ALGO QUE JUSTIFIQUE ESTO], lo cual dificulta el uso de ésta opción al no dejarla disponible para el uso de los programadores de aplicaciones o llevando a errores de programas en el peor caso.

Una última dificultad asociada al uso de la opción \emph{Reuseport} se relaciona con su documentación. La documentación asociada a ésta característica es muy escasa, reducíendose prácticamente a la implementación misma, disponible en el código fuente del propio kernel de Linux. No existe documentación a nivel de usuario que permita comprender ni mucho menos manipular las características de la opción en sí misma. En esa misma linea, aparece como un problema la implementación de ésta característica. Al ser una opción \emph{Hardcodeada} en el kernel mismo de Linux resulta inviable pensar cualquier modificación doméstica pensando en querer aprovechar de su funcionamiento con ciertas modificaciones, ello pues significaría modificar, recompilar e instalar todo el nuevo kernel, manteniendo el riesgo de posibles inestabilidades del resultado, algo que en la práctica es dificilmente aceptable. Ésto último da a entender que la característica \emph{Reuseport} no está pensada para ser modificable según escenarios especificos de operación.