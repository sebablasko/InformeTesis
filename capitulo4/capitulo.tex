\chapter{Propuesta de Solución}
El análisis de las distintas alternativas disponibles para mejorar el rendimiento de la interfaz de red efectuado en el capítulo anterior nos motiva a diseñar e implementar una propuesta de solución que satisfaga ciertos requerimientos puntuales, en pos de ubicarla como una opción viable de uso en entornos como el propuesto.

En el presente capítulo se formalizan los requerimientos mínimos que constituyen nuestra solución ideal. A continuación se desarrolla un modelo para esquematizar el funcionamiento de la solución propuesta y se implementa la misma, para terminar con una evaluación del producto final bajo los mismos entornos que las pruebas desarrolladas a lo largo de la presente investigación.

\section{Formalización de Requerimientos}
Como se ilustró en el capítulo anterior, las distintas soluciones disponibles para mejorar la performance de las estructuras sockets en el kernel de Linux se caracterizan por ser complejas en su funcionamiento ya sea por su implementación sobre aplicaciones actuales como por quebrantar ciertos principios de programación definidos como los sugeridos por el modelo estándar OSI. El objetivo en este punto es caracterizar las especificaciones ideales que debe satisfacer un desarrollo de optimización de la operación de los sockets en el marco de la preservación de caracteristicas deseadas, dadas por dicho modelo.

A raíz de lo anterior, a continuación se especifican las propiedades estructurales que debe contemplar una solución ideal:


\begin{description}
\item[Rendimiento] El requerimiento principal para la solución objetivo constituye el garantizar un buen rendimiento. La solución debe poder brindar tiempos -a lo menos- competitivos con la mejor alternativa evaluada a lo largo de la investigación en curso, que corresponde al rendimiento obtenido con el mecanismo de \emph{ReusePort}.
\item[Bajo Overhead] A fin de lograr una solución con bajo overhead e impacto con el resto del sistema, se debe procurar considerar una alternativa que opere en los niveles más bajos del sistema operativo -A nivel de Kernel idealmente- a fin de evitar la sobrecarga efectuada por concepto de interrupciones y call-chains ???? que son propias de soluciones que operan en espacio de usuario.
\item[Modularidad] El esquema ideal debe ser modular en el sentido de garantizar una sencilla instalación y remoción de un sistema, sin necesitar significativas dependencias de otros componentes. En otra arista de este mismo requerimiento, se necesita una solución que permita modificarciones de manera sencilla, a fin de brindar extensibilidad de la misma.
\item[Adaptable] Finalmente, una propiedad que debe contemplar la solución es ser configurable y adaptable a los distintos entornos y requerimientos que se adapten correctamente a las necesidades de rendimiento que se persigan.
\end{description}

Las características antes mencionadas sirven como requerimientos estructurales en lo que se postula como nuestra propuesta de diseño de solución.

\section{Modelo de Funcionamiento de la Solución}
Tomando en consideración los requerimientos descritos en la sección anterior, se optó por una solución cuyo modelo de funcionamiento fuese como el descrito en la imagen \ref{modeloUDPRedistribuyeModule} denominado como \textbf{UDPRedistributeModule}. Consiste en un \emph{módulo del Kernel} que permite interceptar y redistribuir paquetes (de las características relacionadas al caso de estudio) empleando distintos esquemas de distribución para la redirección de los mismos. Para la versión implementada se desarrollaron 2 esquemas de distribución que se describen en apartados posteriores.

IMAGEN

La justificación de esta desición de diseño se fundamenta en que, con éste enfoque se satisfacen casi todos los requerimientos definidos en la sección anterior: En primer lugar, es un enfoque que añade \textbf{bajo overhead} al sistema, al ser un módulo que se ejecuta en el espacio del Kernel, por lo que cuenta con privilegios que evitan la sobrecarga experimentada por soluciones en espacio usuario. Segundo, siendo un módulo, al momento de instalarlo en el sistema se pueden realizar todas las \textbf{configuraciones} pertinentes, permitiendo un grado de adaptabilidad de acuerdo al entorno y resultado deseado. En tercer lugar, al ser un módulo, es facilmente \textbf{modificable} permitiendo añadir, modificar o eliminar del mismo, reglas definidas o esquemas de distribución. Basta modificarlo, recompilarlo y está listo para operar. Por lo mismo, es facilmente removible del sistema y no guarda ningúna dependencia estricta de terceros.

Las componentes que rigen el modelo en su operación ilustrados en la imagen \ref{modeloUDPRedistribuyeModule} se describen como:

\begin{description}
\item[hook\_port] Valor que determina el puerto a interceptar para la redirección de paquetes.
\item[redirect\_port] Colección de valores que indican los puertos hacia los cuales redistribuir los paquetes interceptados y modificados.
\item[verbose] Índice del grado de detalle con que se guardarán registros de acción del módulo en los mensajes del Kernel.
\end{description}


En la práctica, la operación de la solución propuesta se inspira en el mecanismo de un \emph{proxy} de redistribución de paquetes, modificando valores de las cabeceras de los paquetes intervenidos. El modelo implementa la siguiente lógica de instrucciones:

\begin{enumerate}
\item Interceptar paquetes de tipo UDP y que estén dirigidos a un determinado puerto.
\item Modificar el paquete, actualizando valores como el \emph{checksum} del mismo.
\item Redireccionar el paquete, modificando el puerto de destino de acuerdo al esquema (o algoritmo) de distribución seleccionado.
\item Reincorporación del paquete en el tránsito de distribución del kernel, por la vía ordinaria.
\end{enumerate}

Por su naturaleza de acción, la solución opera estrictamente entre las capas de Red y de Transporte en el modelo OSI, interviniendo esos niveles de abstracción, a través de la modificación de los headers correspondientes al empaquetamiento IP y UDP respectivamente.

\subsection{Esquemas de Distribución}
Como ya se mencionó, la solución desarrollada comprende una etapa de distribución de paquetes de acuerdo a distintos esquemas de distribución, que son reglas para reasignar los paquetes interceptados entre un pool de puertos previamente definidos. En la versión desarrollada del \textbf{UDPRedistributeModule} se implementaron 2 esquemas de distribución: \emph{RandomSched} y \emph{SequentialSched}.

\subsubsection{RandomSched}
El esquema de distribución \emph{RandomSched} realiza una distribución entre puertos de manera aleatoria. La aleatoriedad de éste esquema se consigue por medio de la llamada de sistema \verb=get_random_bytes()= que sugiere una distribución aleatorizada de resultados y redistribuyendo los paquetes de acuerdo a la aplicación de un módulo entre el total de puertos blanco de redistribución del módulo. La utilización de dicha función se justifica también en ser uno de los mecanismos más sencillos de obtener aleatoriedad en demanda en el espacio del Kernel.

\begin{figure}[th!]
\centering
\subfigure[text1]{
	\includegraphics[width=.3\textwidth]{imagenes/fcfm}
}
\subfigure[text2]{
	\includegraphics[width=.3\textwidth]{imagenes/fcfm}
}
\subfigure[text3]{
	\includegraphics[width=.3\textwidth]{imagenes/fcfm}
}
\caption{Evolución en la distribución de paquetes usando el esquema aleatorio por \emph{RandomSched}.}
\label{fig:RandomSched}
\end{figure}

A pesar de que el esquema en promedio promete una distribución uniforme entre los puertos, en la práctica es posible que la carga no sea en efecto perfectamente distribuida, por lo que éste esquema es práctico en escenarios donde se desee cierta entropía en la reasaignación de carga entre puertos de destino.

\subsubsection{SequentialSched}
El segundo esquema de distribución denominado \emph{SequentialSched} hace una distribución secuencial entre los distintos puertos de destino de distribución asignados en el módulo. De ésta manera, éste esquema consigue una perfecta distribución entre puertos de redirección logrando una carga equitativa entre todos ellos.

\begin{figure}[th!]
\centering
\subfigure[text1]{
	\includegraphics[width=.3\textwidth]{imagenes/fcfm}
}
\subfigure[text2]{
	\includegraphics[width=.3\textwidth]{imagenes/fcfm}
}
\subfigure[text3]{
	\includegraphics[width=.3\textwidth]{imagenes/fcfm}
}
\caption{Evolución en la distribución de paquetes usando el esquema secuencial por \emph{SequentialSched}.}
\label{fig:SequentialSched}
\end{figure}

\section{Implementación}
Al ser un módulo del kernel, existen diversas guias técnicas para respaldar la construcción del mismo \cite{algunawea}. Para poder implementar las operaciones de interferencia de paquetes en módulo, se utilizó el framework de Linux \emph{Hook NetFilters}.

\subsection{NetFilters Framework}
Aka, una descripción de que son los hookNetfilters

\

\section{Instalación y Utilización}
Manteniendo la dinámica de un módulo de kernel, la solución requiere ser primero compilada y luego instalada en el sistema de acuerdo a los comandos tradicionales para dicho proposito de que dispone un sistema Linux.

\subsection{Compilación}
Como con todo módulo, se requiere disponer tanto de los encabezados o cabeceras del Kernel, además de su código fuente. Las distribuciones actuales incorporan mecanismos muy simples para poder obtener esos recursos sin mayores problemas.

\begin{listing}
\caption{main}
\begin{minted}[frame=lines,bgcolor=LightGray]{bash}
 >>> a = 1 
 >>> b = 2
 >>> a b +
\end{minted}
\end{listing}


\subsection{Instalación y Configuración}
\subsection{Utilización}

\section{Rendimiento en la Práctica}

\begin{defn}[ver \cite{KAR00}] Definición definitiva $$\frac{d}{dx}\int_a^xf(y)dy=f(x).$$\end{defn}

\begin{teo}[ver \cite{KAR00}] Definición definitiva $$\frac{d}{dx}\int_a^xf(y)dy=f(x).$$\end{teo}

\begin{prop}[ver \cite{KAR00}] Definición definitiva $$\frac{d}{dx}\int_a^xf(y)dy=f(x).$$\end{prop}

\begin{obs}[ver \cite{KAR00}] Definición definitiva $$\frac{d}{dx}\int_a^xf(y)dy=f(x).$$\end{obs}

\begin{ej}[ver \cite{KAR00}] Definición definitiva $$\frac{d}{dx}\int_a^xf(y)dy=f(x).$$\end{ej}