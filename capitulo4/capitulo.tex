\chapter{Propuesta de Solución}
El análisis de las distintas alternativas disponibles para mejorar el rendimiento de la interfaz de red efectuado en el capítulo anterior nos motiva a diseñar e implementar una propuesta de solución que satisfaga ciertos requerimientos puntuales, en pos de ubicarla como una opción viable de uso en entornos como el propuesto.

En el presente capítulo se formalizan los requerimientos mínimos que constituyen nuestra solución ideal. A continuación se desarrolla un modelo para esquematizar el funcionamiento de la solución propuesta y se implementa la misma, para terminar con una evaluación del producto final bajo los mismos entornos que las pruebas desarrolladas a lo largo de la presente investigación.

\section{Formalización de Requerimientos}
Como se ilustró en el capítulo anterior, las distintas soluciones disponibles para mejorar la performance de las estructuras sockets en el kernel de Linux se caracterizan por ser complejas en su funcionamiento ya sea por su implementación para funcionar sobre aplicaciones ya desplegadas en un sistema, o por quebrantar ciertos principios de programación definidos como los sugeridos por el modelo estándar OSI con consecuencias como tener que modificar todo el codigo de los programas operativos. El objetivo en este punto es caracterizar las especificaciones ideales que debe satisfacer un desarrollo de optimización de la operación de los sockets en el marco de la preservación de caracteristicas deseadas, dadas por dicho modelo.

A raíz de lo anterior, a continuación se especifican las propiedades estructurales que debe contemplar una solución ideal:


\begin{description}
\item[Rendimiento] El requerimiento principal para la solución objetivo constituye el garantizar un buen rendimiento. La solución debe poder brindar tiempos -a lo menos- competitivos con la mejor alternativa evaluada a lo largo de la investigación en curso, que corresponde al rendimiento obtenido con el mecanismo de \emph{ReusePort}.
\item[Bajo Overhead] A fin de lograr una solución con bajo overhead e impacto con el resto del sistema, se debe procurar considerar una alternativa que opere en los niveles más bajos del sistema operativo -A nivel de Kernel idealmente- a fin de evitar la sobrecarga efectuada por concepto de interrupciones y call-chains ???? que son propias de soluciones que operan en espacio de usuario.
\item[Modularidad] El esquema ideal debe ser modular en el sentido de garantizar una sencilla instalación y remoción de un sistema, sin necesitar significativas dependencias de otros componentes. En otra arista de este mismo requerimiento, se necesita una solución que permita modificarciones de manera sencilla, a fin de brindar extensibilidad de la misma.
\item[Adaptabilidad] Finalmente, una propiedad que debe contemplar la solución es ser configurable y adaptable a los distintos entornos y requerimientos que se adapten correctamente a las necesidades de rendimiento que se persigan.
\end{description}

Las características antes mencionadas sirven como requerimientos estructurales en lo que se postula como nuestra propuesta de diseño de solución.

\section{Modelo de Funcionamiento de la Solución}
Tomando en consideración los requerimientos descritos en la sección anterior, se optó por una solución cuyo modelo de funcionamiento fuese como el descrito en la imagen \ref{modeloUDPRedistribuyeModule} denominado como \textbf{UDPRedistributeModule}. Consiste en un \emph{módulo del Kernel} que permite interceptar y redistribuir paquetes (de las características relacionadas al caso de estudio) empleando distintos esquemas de distribución para la redirección de los mismos. Para la versión implementada se desarrollaron 2 esquemas de distribución que se describen en apartados posteriores.

IMAGEN

La justificación de esta desición de diseño se fundamenta en que, con éste enfoque se satisfacen casi todos los requerimientos definidos en la sección anterior: En primer lugar, es un enfoque que añade \textbf{bajo overhead} al sistema, al ser un módulo que se ejecuta en el espacio del Kernel, por lo que cuenta con privilegios que evitan la sobrecarga experimentada por soluciones en espacio usuario. Segundo, siendo un módulo, al momento de instalarlo en el sistema se pueden realizar todas las \textbf{configuraciones} pertinentes, permitiendo un grado de adaptabilidad de acuerdo al entorno y resultado deseado. En tercer lugar, al ser un módulo, es facilmente \textbf{modificable} permitiendo añadir, modificar o eliminar del mismo, reglas definidas o esquemas de distribución. Basta modificarlo, recompilarlo y está listo para operar. Por lo mismo, es facilmente removible del sistema y no guarda ningúna dependencia estricta de terceros.

Las componentes que rigen el modelo en su operación ilustrados en la imagen \ref{modeloUDPRedistribuyeModule} se describen como:

\begin{description}
\item[hook\_port] Valor que determina el puerto a interceptar para la redirección de paquetes.
\item[redirect\_port] Colección de valores que indican los puertos hacia los cuales redistribuir los paquetes interceptados y modificados.
\item[verbose] Índice del grado de detalle con que se guardarán registros de acción del módulo en los mensajes del Kernel.
\end{description}


En la práctica, la operación de la solución propuesta se inspira en el mecanismo de un \emph{proxy} de redistribución de paquetes, modificando valores de las cabeceras de los paquetes intervenidos. El modelo implementa la siguiente lógica de instrucciones:

\begin{enumerate}
\item Interceptar paquetes de tipo UDP y que estén dirigidos a un determinado puerto.
\item Modificar el paquete, actualizando valores como el \emph{checksum} del mismo.
\item Redireccionar el paquete, modificando el puerto de destino de acuerdo al esquema (o algoritmo) de distribución seleccionado.
\item Reincorporación del paquete en el tránsito de distribución del kernel, por la vía ordinaria.
\end{enumerate}

Por su naturaleza de acción, la solución opera estrictamente entre las capas de Red y de Transporte en el modelo OSI, interviniendo esos niveles de abstracción, a través de la modificación de los headers correspondientes al empaquetamiento IP y UDP respectivamente.

\subsection{Esquemas de Distribución}
Como ya se mencionó, la solución desarrollada comprende una etapa de distribución de paquetes de acuerdo a distintos esquemas de distribución, que son reglas para reasignar los paquetes interceptados entre un pool de puertos previamente definidos. En la versión desarrollada del \textbf{UDPRedistributeModule} se implementaron 2 esquemas de distribución: \emph{RandomSched} y \emph{SequentialSched}.

\subsubsection{RandomSched}
El esquema de distribución \emph{RandomSched} realiza una distribución entre puertos de manera aleatoria. La aleatoriedad de éste esquema se consigue por medio de la llamada de sistema \verb=get_random_bytes()= que sugiere una distribución aleatorizada de resultados y redistribuyendo los paquetes de acuerdo a la aplicación de un módulo entre el total de puertos blanco de redistribución del módulo. La utilización de dicha función se justifica también en ser uno de los mecanismos más sencillos de obtener aleatoriedad en demanda en el espacio del Kernel.

\begin{figure}[th!]
\centering
\subfigure[text1]{
	\includegraphics[width=.3\textwidth]{imagenes/fcfm}
}
\subfigure[text2]{
	\includegraphics[width=.3\textwidth]{imagenes/fcfm}
}
\subfigure[text3]{
	\includegraphics[width=.3\textwidth]{imagenes/fcfm}
}
\caption{Evolución en la distribución de paquetes usando el esquema aleatorio por \emph{RandomSched}.}
\label{fig:RandomSched}
\end{figure}

A pesar de que el esquema en promedio promete una distribución uniforme entre los puertos, en la práctica es posible que la carga no sea en efecto perfectamente distribuida, por lo que éste esquema es práctico en escenarios donde se desee cierta entropía en la reasaignación de carga entre puertos de destino.

\subsubsection{SequentialSched}
El segundo esquema de distribución denominado \emph{SequentialSched} hace una distribución secuencial entre los distintos puertos de destino de distribución asignados en el módulo. De ésta manera, éste esquema consigue una perfecta distribución entre puertos de redirección logrando una carga equitativa entre todos ellos.

\begin{figure}[th!]
\centering
\subfigure[text1]{
	\includegraphics[width=.3\textwidth]{imagenes/fcfm}
}
\subfigure[text2]{
	\includegraphics[width=.3\textwidth]{imagenes/fcfm}
}
\subfigure[text3]{
	\includegraphics[width=.3\textwidth]{imagenes/fcfm}
}
\caption{Evolución en la distribución de paquetes usando el esquema secuencial por \emph{SequentialSched}.}
\label{fig:SequentialSched}
\end{figure}

\section{Implementación}
Al ser un módulo del kernel, existen diversas guias técnicas para respaldar la construcción del mismo ?????????. Para poder implementar las operaciones de interferencia de paquetes en módulo, se utilizó el framework de Linux: \emph{Hook NetFilters}.

\subsection{NetFilter Framework}
Netfilter es un framework disponible en el núcleo de sistemas Linux que permite la manipulación de paquetes IP en distintos niveles del tránsito de los mismos a través del kernel. Para ello, Netfilters provee una interfaz para implementar los denominados \emph{hooks}, que son funciones de interceptación de paquetes donde se da la libertad de programar libremente operaciones sobre cada paquete intervenido. Los \emph{hooks} implementados deben ser registrados en el sistema y es el mismo kernel el encargado de incluirlos en su rutina de inspección de paquetes a medida que los mismos van llegando al sistema, aplicándolos de acuerdo a reglas de prioridad bien definidas. Netfilters es una de las herramientas más potentes para la manipulación de paquetes, siendo la base de distintas herramientas que operan en espacio usuario como es \textbf{IPTables}.

Las capacidades de manipulación que provee Netfilters es bastante poderosa, abarcando un amplio espacio de acción en el sistema, postulandose como una interesante herramienta para utilizar como solución al desafío planteado.

\subsubsection{Arquitectura de Interrupción en Netfilter}
El framework provee una arquitectura de seguimiento de los distintos paquetes para interceptar que se modela en un esquema definido en la imagen \ref{netfilterArchitecture}. Ésta arquitectura es lo suficientemente detallada como para intervenir paquetes en distintos niveles de comunicación y transito a través del kernel.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=.5]{imagenes/netfilterArchitecture}
	\caption{Esquema de la arquitectura de interrupción disponible para la intervención de paquetes provisto por el Netfilters Framework}
	\label{netfilterArchitecture}
\end{figure}


El esquema ilustrado en la figura \ref{netfilterArchitecture} da cuenta del flujo que recorre un paquete en el kernel en consideración de los modos de intervención que brinda el framework de Netfilters. Cada uno de los puntos ilustrados en dicho diagrama es un potencial punto de intervención, y da cuenta de alguna etapa en el arrivo o salida de un paquete. Los distintos puntos de intervención se ilustran a continuación:

\begin{description}
\item[NF\_IP\_PRE\_ROUTING] La entrada
\item[NF\_IP\_INPUT] La entrada
\item[NF\_IP\_FORWARD] La El reenvío
\item[NF\_IP\_OUTPUT] La entrada
\item[NF\_IP\_POST\_ROUTING] La salida
\end{description}

\subsubsection{Implementación de funciones de Interrupción}

Para aprovechar las funcionaldiades del framework de Netfilters, una de las alternativas más sencillas es a través de la implementación de un módulo del Kernel, Para ello, basta incluir las directivas de encabezados del framework en el módulo (\verb=#include <linux/netfilter.h>=) e implementar los mecanísmos de registro del \emph{hook} en el sistema, especificando sus opciones como prioridad, familia y punto de interrupción, usando los valores de constantes provistos por el mismo framework, además de implementar la función a aplicar sobre cada paquete intervenido. Para este último aspecto es necesario seguir la convención que especifica el mismo framework.

\definecolor{mygray}{rgb}{0.95,0.95,0.95}
\lstset{language=C,
		frame=single,
		backgroundcolor=\color{mygray}
		}
\begin{lstlisting}[caption=ESO]
static unsigned int hook_func(
            		unsigned int hooknum,
            		struct sk_buff *skb, 
            		const struct net_device *in, 
            		const struct net_device *out, 
            		int (*okfn)(struct sk_buff *));
\end{lstlisting}

Esta interfaz de función comprende 5 valores a recibir que contienen información que se puede manipular en la implementación de la función \verb=hook_func= misma:
\begin{description}
\item[hooknum] La entrada
\item[skb] La El reenvío
\item[in] La salida
\item[out] La El reenvío
\item[sk\_buff] La salida
\end{description}

\begin{description}
\item[] Valor que determina el puerto a interceptar para la redirección de paquetes.
\end{description}




\subsection{Código Fuente}
La solución fue elaborada siguiendo los principios de construcción de un módulo estándar de Linux. Básicamente se implementaron los métodos \verb=init_module= y \verb=cleanup_module= para la instalación y eliminación del módulo respectivamente. Es en el primer método -\verb=init_module=- donde se gatilla la construcción y el registro del filtro definido para la interceptación de los paquetes, con las reglas definidas.

Es en el proceso de registro del filtro donde se definen las caracteristicas del mismo. Para la solución propuesta se definieron carácteristicas como alta prioridad, naturaleza de paquetes interceptados y punto de intercepción.


\section{Instalación y Utilización}
Manteniendo la dinámica de un módulo de kernel, la solución requiere ser primero compilada y luego instalada en el sistema de acuerdo a los comandos tradicionales para dicho proposito de que dispone un sistema Linux.

\subsection{Compilación}
Como con todo módulo, se requiere disponer tanto de los encabezados o cabeceras del Kernel, además de su código fuente. Las distribuciones actuales incorporan mecanismos muy simples para poder obtener esos recursos sin mayores problemas.

\begin{listing}
\caption{main}
\begin{minted}[frame=lines,bgcolor=LightGray]{bash}
 >>> a = 1 
 >>> b = 2
 >>> a b +
\end{minted}
\end{listing}


\subsection{Instalación y Configuración}
\subsection{Utilización}

\section{Rendimiento en la Práctica}

\begin{defn}[ver \cite{KAR00}] Definición definitiva $$\frac{d}{dx}\int_a^xf(y)dy=f(x).$$\end{defn}

\begin{teo}[ver \cite{KAR00}] Definición definitiva $$\frac{d}{dx}\int_a^xf(y)dy=f(x).$$\end{teo}

\begin{prop}[ver \cite{KAR00}] Definición definitiva $$\frac{d}{dx}\int_a^xf(y)dy=f(x).$$\end{prop}

\begin{obs}[ver \cite{KAR00}] Definición definitiva $$\frac{d}{dx}\int_a^xf(y)dy=f(x).$$\end{obs}

\begin{ej}[ver \cite{KAR00}] Definición definitiva $$\frac{d}{dx}\int_a^xf(y)dy=f(x).$$\end{ej}